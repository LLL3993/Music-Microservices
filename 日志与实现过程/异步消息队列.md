12.23 使用rabbitmq容器实现异步消息队列

# 异步消息队列（RabbitMQ + Direct Exchange）

## 目标

- 在 Docker 部署场景下接入 RabbitMQ 异步消息队列。
- 使用 Direct Exchange。

## 实现思路

### 1) 为什么选这两个事件

当前系统里 `list-service` 的数据（收藏/歌单/歌单详情）会引用：

- `user-service` 的 `username`
- `meta-service` 的 `songName`

为了减少跨服务强耦合和同步级联删除，将“引用方清理”改为事件驱动：

- `user-service` 删除用户后发布 `user.deleted` 事件
- `meta-service` 删除歌曲后发布 `meta.song.deleted` 事件
- `list-service` 订阅上述事件并执行数据清理

这样做的效果：

- 删除用户/歌曲时不需要同步调用 `list-service`
- `list-service` 通过消息队列异步完成数据清理（最终一致）

### 2) 交换机与路由设计（Direct Exchange）

- Exchange（直连交换机）：`music.events`
- Routing Key：
  - `user.deleted`
  - `meta.song.deleted`
- Queue（由 `list-service` 声明并绑定到 exchange）：
  - `list.user.deleted` 绑定 `user.deleted`
  - `list.song.deleted` 绑定 `meta.song.deleted`

Direct Exchange 会根据 `routingKey` 精确投递到对应队列。

### 3) “仅 Docker 场景启用”的实现方式

通过 Spring Profile 隔离：

- `docker-compose.yml` 为后端容器设置 `SPRING_PROFILES_ACTIVE=docker`
- RabbitMQ 相关 Bean（exchange/queue/binding/json converter）与 `@RabbitListener` 消费者仅在 `docker` profile 下启用
- 非 Docker（本地）profile 下：
  - 发布侧使用 `Noop...Publisher`（空实现）
  - 不会创建队列/绑定、不启动消费者，因此不会尝试连接 RabbitMQ

## 代码改动（关键文件）

### 1) Docker 编排

新增 RabbitMQ 容器与健康检查：

- `docker-compose.yml:61`

并让 `user-service` / `user-service-2` / `meta-service` / `list-service` 等待 RabbitMQ 就绪：

- `docker-compose.yml:76`、`docker-compose.yml:99`、`docker-compose.yml:119`、`docker-compose.yml:140`

### 2) Docker 配置（Spring Boot）

在 Docker profile 注入 RabbitMQ 连接参数：

- `user-service/src/main/resources/application-docker.yml:31`
- `meta-service/src/main/resources/application-docker.yml:29`
- `list-service/src/main/resources/application-docker.yml:34`

默认账号来自 compose：

- `RABBITMQ_DEFAULT_USER=music`
- `RABBITMQ_DEFAULT_PASS=music123`

### 3) 发布侧（user-service / meta-service）

`user-service`：删除用户后发布事件

- 删除后发布：`user-service/src/main/java/com/zjsu/lyy/user_service/service/UserService.java:75`
- Direct Exchange 常量：`user-service/src/main/java/com/zjsu/lyy/user_service/messaging/RabbitMqConstants.java:9`
- Docker profile 发布实现：`user-service/src/main/java/com/zjsu/lyy/user_service/messaging/RabbitUserEventPublisher.java:11`
- 非 Docker profile 空实现：`user-service/src/main/java/com/zjsu/lyy/user_service/messaging/NoopUserEventPublisher.java:8`

`meta-service`：删除歌曲后发布事件

- 删除后发布：`meta-service/src/main/java/com/zjsu/lyy/meta_service/service/MetaService.java:85`
- Direct Exchange 常量：`meta-service/src/main/java/com/zjsu/lyy/meta_service/messaging/RabbitMqConstants.java:9`
- Docker profile 发布实现：`meta-service/src/main/java/com/zjsu/lyy/meta_service/messaging/RabbitMetaEventPublisher.java:11`
- 非 Docker profile 空实现：`meta-service/src/main/java/com/zjsu/lyy/meta_service/messaging/NoopMetaEventPublisher.java:8`

### 4) 消费侧（list-service）

`list-service` 负责声明队列并消费消息：

- Exchange/Queue/Binding（docker profile）：`list-service/src/main/java/com/zjsu/lyy/list_service/messaging/RabbitMqDockerConfig.java:15`
- 消费者（docker profile）：`list-service/src/main/java/com/zjsu/lyy/list_service/messaging/ListEventConsumer.java:12`
- 清理逻辑：`list-service/src/main/java/com/zjsu/lyy/list_service/messaging/ListCleanupService.java:12`
- Repository 批量删除方法：
  - `list-service/src/main/java/com/zjsu/lyy/list_service/repository/FavoriteRepository.java:13`
  - `list-service/src/main/java/com/zjsu/lyy/list_service/repository/PlaylistRepository.java:19`
  - `list-service/src/main/java/com/zjsu/lyy/list_service/repository/PlaylistDetailRepository.java:17`

清理规则：

- 收到 `user.deleted`：删除该 `username` 的收藏/歌单/歌单详情
- 收到 `meta.song.deleted`：删除该 `songName` 的收藏/歌单详情

## 实现日志（运行时可观察点）

### 1) 发布侧日志

当你在 Docker 环境调用删除接口后：

- `user-service` 容器日志会出现：

```text
Published user.deleted for username=<username>
```

- `meta-service` 容器日志会出现：

```text
Published meta.song.deleted for songName=<songName>
```

### 2) 消费侧日志

`list-service` 消费并完成清理后会出现：

```text
Consumed user.deleted eventId=<eventId> username=<username>
Consumed meta.song.deleted eventId=<eventId> songName=<songName>
```

## Docker 环境测试（命令）

以下命令假设你在服务器（或有 Docker 的机器）仓库根目录执行，且具备 `curl`、`python3`。

### 0) 启动

```bash
docker compose up -d --build
```

可选：打开 RabbitMQ 管理台

- `http://<server-ip>:15672/`
- 用户名：`music`
- 密码：`music123`

### 1) 测试 user.deleted -> list-service 清理

准备环境变量：

```bash
export GW="http://localhost:8090"
export USERNAME="mq_user"
export PASSWORD="123456"
export EMAIL="mq_user@example.com"
```

注册并拿 token 与 userId：

```bash
resp="$(
  curl -s -X POST "$GW/api/auth/register" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$USERNAME\",\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}"
)"

export TOKEN="$(echo "$resp" | python3 -c 'import sys,json;print(json.load(sys.stdin)["token"])')"
export USER_ID="$(echo "$resp" | python3 -c 'import sys,json;print(json.load(sys.stdin)["user"]["id"])')"

echo "token(head)=${TOKEN:0:16}... userId=$USER_ID"
```

创建一首歌（用于后续收藏/歌单详情校验通过）：

```bash
meta_resp="$(
  curl -s -X POST "$GW/api/meta" \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"songName":"MQ Song","artist":"MQ Artist"}'
)"

export SONG_ID="$(echo "$meta_resp" | python3 -c 'import sys,json;print(json.load(sys.stdin)["id"])')"
```

创建收藏：

```bash
curl -s -X POST "$GW/api/favorites" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"songName":"MQ Song"}'
echo
```

创建歌单 + 歌单详情：

```bash
curl -s -X POST "$GW/api/playlists" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"playlistName":"MQ List","description":"","isPublic":true}'
echo

curl -s -X POST "$GW/api/playlist-details" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"playlistName":"MQ List","songName":"MQ Song"}'
echo
```

删除用户（触发 `user.deleted`）：

```bash
curl -s -X DELETE "$GW/api/users/$USER_ID" \
  -H "Authorization: Bearer $TOKEN" -i
```

观察日志（示例）：

```bash
docker compose logs -f user-service
docker compose logs -f list-service
```

验证 list-service 数据被清理（仍然可以用旧 token 访问，因为 token 未过期且网关只校验 JWT 本身）：

```bash
curl -s "$GW/api/favorites/username" -H "Authorization: Bearer $TOKEN" | head
curl -s "$GW/api/playlists/username" -H "Authorization: Bearer $TOKEN" | head
curl -s "$GW/api/playlist-details?playlistName=MQ%20List" -H "Authorization: Bearer $TOKEN" | head
```

### 2) 测试 meta.song.deleted -> list-service 清理

（重新注册一个用户，保证能创建收藏/歌单）

```bash
export USERNAME="mq_user2"
export EMAIL="mq_user2@example.com"

resp="$(
  curl -s -X POST "$GW/api/auth/register" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$USERNAME\",\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}"
)"

export TOKEN="$(echo "$resp" | python3 -c 'import sys,json;print(json.load(sys.stdin)["token"])')"
```

创建新歌曲并收藏：

```bash
meta_resp="$(
  curl -s -X POST "$GW/api/meta" \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"songName":"MQ Song 2","artist":"MQ Artist"}'
)"

export SONG_ID="$(echo "$meta_resp" | python3 -c 'import sys,json;print(json.load(sys.stdin)["id"])')"

curl -s -X POST "$GW/api/favorites" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"songName":"MQ Song 2"}'
echo
```

删除歌曲（触发 `meta.song.deleted`）：

```bash
curl -s -X DELETE "$GW/api/meta/$SONG_ID" \
  -H "Authorization: Bearer $TOKEN" -i
```

观察日志：

```bash
docker compose logs -f meta-service
docker compose logs -f list-service
```

验证收藏被清理：

```bash
curl -s "$GW/api/favorites/username" -H "Authorization: Bearer $TOKEN" | head
```

## 备注

- 本实现把消息队列仅作为 Docker 部署能力接入；本地 profile 不依赖 RabbitMQ。
- 当前采用“删除后立即发布事件”的方式（非 Outbox）。如果未来要进一步提升可靠性（避免 DB 删除成功但消息发布失败），可以引入 Outbox/本地消息表 + 定时投递。

