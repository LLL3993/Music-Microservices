12.21 实现服务间通信与负载均衡

# 服务间通信与负载均衡（OpenFeign + Nacos + Resilience4j）

## 目标

- 在 `list-service` 中使用 OpenFeign 通过服务名调用 `user-service`、`meta-service`，替换原先的 `RestTemplate`/硬编码地址方式
- 为 Feign 调用接入熔断与降级：
  - Resilience4j 熔断器：失败率阈值 50%，滑动窗口 10 次（COUNT_BASED）
  - FallbackFactory：根据异常类型做不同降级策略
- Docker 场景下启动 `user-service` 的第二实例（端口 8084），用于验证负载均衡效果
- 本地（无 Docker / 无 Nacos）仍可独立调试

## 实现内容

### 1) list-service：OpenFeign 客户端改造

- 新增/改造 Feign Client：
  - `list-service/src/main/java/com/zjsu/lyy/list_service/integration/UserClient.java:8`
  - `list-service/src/main/java/com/zjsu/lyy/list_service/integration/MetaClient.java:8`
- 启用 Feign：
  - `list-service/src/main/java/com/zjsu/lyy/list_service/ListServiceApplication.java:8`

Feign Client 的核心点：

- `@FeignClient(name = "user-service", ...)` / `@FeignClient(name = "meta-service", ...)`
- `name` 直接写服务名，运行时由注册中心/负载均衡组件解析到可用实例

### 2) list-service：404 语义对齐（ErrorDecoder）

为确保 “下游返回 404” 能在 `list-service` 里稳定转成统一的业务异常（`NotFoundException`），增加 Feign 的 `ErrorDecoder`：

- `list-service/src/main/java/com/zjsu/lyy/list_service/integration/FeignSupportConfig.java:12`

行为：

- 当调用 `UserClient#assertUserExists` 返回 404：抛出 `NotFoundException("用户不存在")`
- 当调用 `MetaClient#assertSongExists` 返回 404：抛出 `NotFoundException("歌曲不存在")`

### 3) list-service：Resilience4j 熔断 + Fallback 降级

#### 3.1 开启 Feign CircuitBreaker

- `list-service/src/main/resources/application.yml:10`

关键配置：

- `spring.cloud.openfeign.circuitbreaker.enabled=true`
- `spring.cloud.openfeign.circuitbreaker.group.enabled=true`

其中 `group.enabled=true` 用于让熔断器实例名按 Feign Client 维度聚合（即 `user-service` / `meta-service`），便于与 Resilience4j 的 `instances` 配置对齐。

#### 3.2 熔断器参数（50% / 10 次）

- `list-service/src/main/resources/application.yml:41`

当前值：

- `failureRateThreshold: 50`
- `slidingWindowSize: 10`
- `slidingWindowType: COUNT_BASED`
- `minimumNumberOfCalls: 10`

#### 3.3 FallbackFactory 降级策略

- `list-service/src/main/java/com/zjsu/lyy/list_service/integration/UserClientFallbackFactory.java:10`
- `list-service/src/main/java/com/zjsu/lyy/list_service/integration/MetaClientFallbackFactory.java:10`

降级策略（按异常分类）：

- `NotFoundException`：直接透传（保持业务语义）
- `FeignException.NotFound`：直接透传（保持 404 语义）
- `CallNotPermittedException`（熔断器打开后的拒绝调用）：直接 `return;`，相当于“跳过跨服务存在性校验”（允许核心业务继续执行）
- 其它异常：抛出 `IllegalStateException("xxx-service 调用失败", cause)`，让调用方明确感知依赖服务异常

### 4) list-service：本地无 Nacos 的可运行性（Simple Discovery）

为了本地调试不依赖 Nacos，在 `list-service` 的 `application.yml` 中使用 `spring.cloud.discovery.client.simple.instances` 提供服务名到 URI 的映射：

- `list-service/src/main/resources/application.yml:13`

示例：

- `user-service -> http://localhost:8081`
- `meta-service -> http://localhost:8082`

Docker 场景下会通过 profile 关闭 simple discovery 并启用 Nacos：

- `list-service/src/main/resources/application-docker.yml:1`

### 5) Docker：启动 user-service 第二实例（8084）

在 `docker-compose.yml` 中新增 `user-service-2`：

- `docker-compose.yml:69`

关键点：

- 复用同一镜像构建：`context: ./user-service`
- 指定端口：`SERVER_PORT: 8084`，映射 `8084:8084`
- 同样注册到 Nacos：`SPRING_PROFILES_ACTIVE: docker`

这样 Nacos 中 `user-service` 会出现两个实例（8081 / 8084），供调用方进行负载均衡。

## 代码调用链（list-service -> user/meta）

以 `FavoriteService` 为例，跨服务校验由 Feign 完成：

- `list-service/src/main/java/com/zjsu/lyy/list_service/service/FavoriteService.java:75`

逻辑：

- `services.validation.enabled=true` 时：
  - `userClient.assertUserExists(username)`
  - `metaClient.assertSongExists(songName)`
- 关闭校验（测试环境默认关闭）：`services.validation.enabled=false`

## 如何验证

### 0) 通用准备（建议先复制这一段）

说明：

- 下述命令默认你在虚拟机里使用 Linux bash（有 `curl`、`python3`）
- 所有对后端的业务调用优先经 `gateway-service`（`http://localhost:8090`）走，符合“外部请求统一走网关”的约束

先设置几个环境变量：

```bash
export GW="http://localhost:8090"
export USERNAME="lbtest"
export PASSWORD="123456"
export EMAIL="lbtest@example.com"
```

注册并拿到 `TOKEN`（如果用户已存在，会返回 409；直接改个 `USERNAME/EMAIL` 再执行一次即可）：

```bash
export TOKEN="$(
  curl -s -X POST "$GW/api/auth/register" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$USERNAME\",\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}" \
  | python3 -c 'import sys,json;print(json.load(sys.stdin)["token"])'
)"

echo "$TOKEN" | head -c 24 && echo "..."
```

或者如果这个账号已经注册，也可以通过登录拿 token：

```bash
export TOKEN="$(
  curl -s -X POST "$GW/api/auth/login" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$USERNAME\",\"password\":\"$PASSWORD\"}" \
  | python3 -c 'import sys,json;print(json.load(sys.stdin)["token"])'
)"

echo "$TOKEN" | head -c 24 && echo "..."
```

### A) 验证 Feign 服务名调用（本地无 Nacos）

前置：

- 启动 `user-service`（8081）、`meta-service`（8082）、`list-service`（8083）
- `list-service/src/main/resources/application.yml` 中已配置 simple discovery 映射，无需 Nacos

验证点：

- 调用 `list-service` 的业务接口时能够正常触发对 `user-service`、`meta-service` 的校验
- 例如对不存在用户/歌曲应返回 404，并带有 `用户不存在`/`歌曲不存在`

验证命令：

1) 验证网关是否生效（不带 token 应返回 401）

```bash
curl -i -s "$GW/api/favorites/username"
```

2) 先造一个“存在的歌曲”（经网关调用 meta-service，需要带 token）

```bash
export SONG_OK="song_ok_$(date +%s)"
curl -i -s -X POST "$GW/api/meta" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"songName\":\"$SONG_OK\",\"artist\":\"demo\"}"
```

3) 再新增收藏（经网关调用 list-service，触发 list->user 与 list->meta 的 Feign 校验）

```bash
curl -i -s -X POST "$GW/api/favorites" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"songName\":\"$SONG_OK\"}"
```

4) 验证“歌曲不存在”会被转换成 `404 + 歌曲不存在`（不预先创建该歌曲）

```bash
export SONG_404="song_not_exists_$(date +%s)"
curl -i -s -X POST "$GW/api/favorites" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"songName\":\"$SONG_404\"}"
```

5) 验证“用户不存在”会被转换成 `404 + 用户不存在`（此条不走网关，直接访问 list-service 并手动传 `X-Username`）

```bash
curl -i -s "http://localhost:8083/api/favorites/username" \
  -H "X-Username: user_not_exists_$(date +%s)"
```

### B) 验证 Nacos + 负载均衡（Docker 场景）

前置：

- 使用 `docker-compose.yml` 启动：`nacos`、`user-service`、`user-service-2`、`meta-service`、`list-service`

验证步骤：

- 确认 Nacos 中 `user-service` 有 2 个实例（8081、8084）
- 验证“高可用/负载均衡效果”：停掉其中一个实例后，`list-service` 仍能通过服务名调用剩余实例完成校验

验证命令（在项目根目录 `Music-Microservices/` 执行）：

1) 查 Nacos：确认 `user-service` 注册了 2 个实例

```bash
curl -s "http://localhost:8848/nacos/v1/ns/instance/list?serviceName=user-service" \
  | python3 -c 'import sys,json;d=json.load(sys.stdin);print("count=",d.get("count"));print("ports=",[h.get("port") for h in d.get("hosts",[])])'
```

2) 先确认当前调用正常（经网关 -> list-service -> user-service 校验）

```bash
curl -s -o /dev/null -w "%{http_code}\n" "$GW/api/favorites/username" \
  -H "Authorization: Bearer $TOKEN"
```

3) 停掉 `user-service`（8081），再次调用应仍然正常（说明能走到 `user-service-2`）

```bash
docker compose stop user-service
curl -s -o /dev/null -w "%{http_code}\n" "$GW/api/favorites/username" \
  -H "Authorization: Bearer $TOKEN"
docker compose start user-service
```

4) 反向验证：停掉 `user-service-2`（8084），再次调用也应仍然正常

```bash
docker compose stop user-service-2
curl -s -o /dev/null -w "%{http_code}\n" "$GW/api/favorites/username" \
  -H "Authorization: Bearer $TOKEN"
docker compose start user-service-2
```

### C) 验证 Resilience4j 熔断 + 降级

目标：在依赖服务异常时，能触发熔断并进入 Fallback。

建议验证方式（Docker 场景最直观）：

1. 让 `user-service` 或 `meta-service` 不可用（例如停止容器）
2. 连续调用会触发 Feign 调用失败
3. 在 10 次窗口内失败率达到 50% 后，熔断器打开
4. 熔断器打开后，FallbackFactory 里捕获 `CallNotPermittedException`，校验逻辑被跳过，核心业务接口可以继续执行

验证点：

- 熔断前：多次请求会出现依赖服务调用失败导致的错误
- 熔断后：同样的请求不再发起下游调用（被拒绝），校验跳过，业务可继续（视业务接口写法而定）

验证命令（以 `user-service` 熔断为例，最直观看到 “失败 -> 熔断后恢复为 200” 的效果）：

1) 停掉两个 user-service 实例，让 list-service 的“用户存在性校验”必然失败

```bash
docker compose stop user-service user-service-2
```

2) 在 10 次滑动窗口内制造失败（默认会看到一串 `500` 或非 `200` 的返回码），应该最后几个输出为200

```bash
for i in $(seq 1 10); do
  curl -s -o /dev/null -w "%{http_code}\n" "$GW/api/favorites/username" \
    -H "Authorization: Bearer $TOKEN"
done
```

3) 再请求一次：预期变为 `200`（熔断打开后被拒绝调用，下游校验被跳过，接口继续执行并返回收藏列表）

```bash
curl -i -s "$GW/api/favorites/username" \
  -H "Authorization: Bearer $TOKEN"
```

4) 恢复 user-service（便于你继续做其它验证）

```bash
docker compose start user-service user-service-2
```

5）这里贴出一个验证示例：

```bash
root@ubuntu114:/home/lll/Music-Microservices# docker compose stop user-service user-service-2
[+] Stopping 2/2
 ✔ Container music-microservices-user-service-2-1  Stopped                                                                                                                    3.3s
 ✔ Container music-microservices-user-service-1    Stopped                                                                                                                    3.0s
root@ubuntu114:/home/lll/Music-Microservices# for i in $(seq 1 10); do
  curl -s -o /dev/null -w "%{http_code}\n" "$GW/api/favorites/username" \
    -H "Authorization: Bearer $TOKEN"
done
500
500
500
500
500
500
500
200
200
200
root@ubuntu114:/home/lll/Music-Microservices# curl -i -s "$GW/api/favorites/username" \
  -H "Authorization: Bearer $TOKEN"
HTTP/1.1 200 OK
transfer-encoding: chunked
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Content-Type: application/json
Date: Sun, 21 Dec 2025 07:22:29 GMT

[]root@ubuntu114:/home/lll/Music-Microservices#
```

## 结论

- `list-service` 的跨服务调用已统一为 OpenFeign 的“服务名调用”
- 本地调试通过 simple discovery 保持独立性，Docker 场景通过 Nacos 实现注册发现
- 通过 Resilience4j + FallbackFactory 实现熔断与可控降级，并可在 Docker 场景下用 `user-service` 双实例验证负载均衡
